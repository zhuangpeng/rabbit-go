// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.19.4
// source: usercenter.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// UserClient is the client API for User service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserClient interface {
	CreateUser(ctx context.Context, in *CreateUserReq, opts ...grpc.CallOption) (*BaseResp, error)
	BatchCreateUsers(ctx context.Context, in *BatchCreateUserReq, opts ...grpc.CallOption) (*IDsResp, error)
	DeleteUser(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*BaseResp, error)
	BatchDeleteUser(ctx context.Context, in *IDsResp, opts ...grpc.CallOption) (*BaseResp, error)
	UpdateProfile(ctx context.Context, in *UpdateProfileReq, opts ...grpc.CallOption) (*BaseResp, error)
	GetUser(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*UserInfoResp, error)
	GetUserList(ctx context.Context, in *PageInfoReq, opts ...grpc.CallOption) (*UserListResp, error)
	UpdateUserStatus(ctx context.Context, in *StatusCodeReq, opts ...grpc.CallOption) (*BaseResp, error)
	Login(ctx context.Context, in *LoginReq, opts ...grpc.CallOption) (*LoginResp, error)
	ChangePassword(ctx context.Context, in *ChangePasswdReq, opts ...grpc.CallOption) (*BaseResp, error)
}

type userClient struct {
	cc grpc.ClientConnInterface
}

func NewUserClient(cc grpc.ClientConnInterface) UserClient {
	return &userClient{cc}
}

func (c *userClient) CreateUser(ctx context.Context, in *CreateUserReq, opts ...grpc.CallOption) (*BaseResp, error) {
	out := new(BaseResp)
	err := c.cc.Invoke(ctx, "/pb.User/CreateUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) BatchCreateUsers(ctx context.Context, in *BatchCreateUserReq, opts ...grpc.CallOption) (*IDsResp, error) {
	out := new(IDsResp)
	err := c.cc.Invoke(ctx, "/pb.User/BatchCreateUsers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) DeleteUser(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*BaseResp, error) {
	out := new(BaseResp)
	err := c.cc.Invoke(ctx, "/pb.User/DeleteUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) BatchDeleteUser(ctx context.Context, in *IDsResp, opts ...grpc.CallOption) (*BaseResp, error) {
	out := new(BaseResp)
	err := c.cc.Invoke(ctx, "/pb.User/BatchDeleteUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) UpdateProfile(ctx context.Context, in *UpdateProfileReq, opts ...grpc.CallOption) (*BaseResp, error) {
	out := new(BaseResp)
	err := c.cc.Invoke(ctx, "/pb.User/UpdateProfile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) GetUser(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*UserInfoResp, error) {
	out := new(UserInfoResp)
	err := c.cc.Invoke(ctx, "/pb.User/GetUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) GetUserList(ctx context.Context, in *PageInfoReq, opts ...grpc.CallOption) (*UserListResp, error) {
	out := new(UserListResp)
	err := c.cc.Invoke(ctx, "/pb.User/GetUserList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) UpdateUserStatus(ctx context.Context, in *StatusCodeReq, opts ...grpc.CallOption) (*BaseResp, error) {
	out := new(BaseResp)
	err := c.cc.Invoke(ctx, "/pb.User/UpdateUserStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) Login(ctx context.Context, in *LoginReq, opts ...grpc.CallOption) (*LoginResp, error) {
	out := new(LoginResp)
	err := c.cc.Invoke(ctx, "/pb.User/Login", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) ChangePassword(ctx context.Context, in *ChangePasswdReq, opts ...grpc.CallOption) (*BaseResp, error) {
	out := new(BaseResp)
	err := c.cc.Invoke(ctx, "/pb.User/ChangePassword", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServer is the server API for User service.
// All implementations must embed UnimplementedUserServer
// for forward compatibility
type UserServer interface {
	CreateUser(context.Context, *CreateUserReq) (*BaseResp, error)
	BatchCreateUsers(context.Context, *BatchCreateUserReq) (*IDsResp, error)
	DeleteUser(context.Context, *IDReq) (*BaseResp, error)
	BatchDeleteUser(context.Context, *IDsResp) (*BaseResp, error)
	UpdateProfile(context.Context, *UpdateProfileReq) (*BaseResp, error)
	GetUser(context.Context, *IDReq) (*UserInfoResp, error)
	GetUserList(context.Context, *PageInfoReq) (*UserListResp, error)
	UpdateUserStatus(context.Context, *StatusCodeReq) (*BaseResp, error)
	Login(context.Context, *LoginReq) (*LoginResp, error)
	ChangePassword(context.Context, *ChangePasswdReq) (*BaseResp, error)
	mustEmbedUnimplementedUserServer()
}

// UnimplementedUserServer must be embedded to have forward compatible implementations.
type UnimplementedUserServer struct {
}

func (UnimplementedUserServer) CreateUser(context.Context, *CreateUserReq) (*BaseResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
}
func (UnimplementedUserServer) BatchCreateUsers(context.Context, *BatchCreateUserReq) (*IDsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCreateUsers not implemented")
}
func (UnimplementedUserServer) DeleteUser(context.Context, *IDReq) (*BaseResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUser not implemented")
}
func (UnimplementedUserServer) BatchDeleteUser(context.Context, *IDsResp) (*BaseResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchDeleteUser not implemented")
}
func (UnimplementedUserServer) UpdateProfile(context.Context, *UpdateProfileReq) (*BaseResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateProfile not implemented")
}
func (UnimplementedUserServer) GetUser(context.Context, *IDReq) (*UserInfoResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUser not implemented")
}
func (UnimplementedUserServer) GetUserList(context.Context, *PageInfoReq) (*UserListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserList not implemented")
}
func (UnimplementedUserServer) UpdateUserStatus(context.Context, *StatusCodeReq) (*BaseResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserStatus not implemented")
}
func (UnimplementedUserServer) Login(context.Context, *LoginReq) (*LoginResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}
func (UnimplementedUserServer) ChangePassword(context.Context, *ChangePasswdReq) (*BaseResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangePassword not implemented")
}
func (UnimplementedUserServer) mustEmbedUnimplementedUserServer() {}

// UnsafeUserServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServer will
// result in compilation errors.
type UnsafeUserServer interface {
	mustEmbedUnimplementedUserServer()
}

func RegisterUserServer(s grpc.ServiceRegistrar, srv UserServer) {
	s.RegisterService(&User_ServiceDesc, srv)
}

func _User_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.User/CreateUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).CreateUser(ctx, req.(*CreateUserReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_BatchCreateUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchCreateUserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).BatchCreateUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.User/BatchCreateUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).BatchCreateUsers(ctx, req.(*BatchCreateUserReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).DeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.User/DeleteUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).DeleteUser(ctx, req.(*IDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_BatchDeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDsResp)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).BatchDeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.User/BatchDeleteUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).BatchDeleteUser(ctx, req.(*IDsResp))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_UpdateProfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateProfileReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).UpdateProfile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.User/UpdateProfile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).UpdateProfile(ctx, req.(*UpdateProfileReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).GetUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.User/GetUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).GetUser(ctx, req.(*IDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_GetUserList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PageInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).GetUserList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.User/GetUserList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).GetUserList(ctx, req.(*PageInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_UpdateUserStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatusCodeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).UpdateUserStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.User/UpdateUserStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).UpdateUserStatus(ctx, req.(*StatusCodeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.User/Login",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).Login(ctx, req.(*LoginReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_ChangePassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangePasswdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).ChangePassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.User/ChangePassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).ChangePassword(ctx, req.(*ChangePasswdReq))
	}
	return interceptor(ctx, in, info, handler)
}

// User_ServiceDesc is the grpc.ServiceDesc for User service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var User_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.User",
	HandlerType: (*UserServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateUser",
			Handler:    _User_CreateUser_Handler,
		},
		{
			MethodName: "BatchCreateUsers",
			Handler:    _User_BatchCreateUsers_Handler,
		},
		{
			MethodName: "DeleteUser",
			Handler:    _User_DeleteUser_Handler,
		},
		{
			MethodName: "BatchDeleteUser",
			Handler:    _User_BatchDeleteUser_Handler,
		},
		{
			MethodName: "UpdateProfile",
			Handler:    _User_UpdateProfile_Handler,
		},
		{
			MethodName: "GetUser",
			Handler:    _User_GetUser_Handler,
		},
		{
			MethodName: "GetUserList",
			Handler:    _User_GetUserList_Handler,
		},
		{
			MethodName: "UpdateUserStatus",
			Handler:    _User_UpdateUserStatus_Handler,
		},
		{
			MethodName: "Login",
			Handler:    _User_Login_Handler,
		},
		{
			MethodName: "ChangePassword",
			Handler:    _User_ChangePassword_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "usercenter.proto",
}

// StationClient is the client API for Station service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StationClient interface {
	CreateStation(ctx context.Context, in *CreateStationReq, opts ...grpc.CallOption) (*BaseResp, error)
	DeleteStation(ctx context.Context, in *IDResp, opts ...grpc.CallOption) (*BaseResp, error)
	GetStation(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*GetStationResp, error)
	GetStationByUser(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*GetStationByUserResp, error)
	UpdateStation(ctx context.Context, in *UpdateStationReq, opts ...grpc.CallOption) (*BaseResp, error)
	UpdateStationSort(ctx context.Context, in *ChangePositionReq, opts ...grpc.CallOption) (*BaseResp, error)
	UpdateDep(ctx context.Context, in *ChangeDept, opts ...grpc.CallOption) (*BaseResp, error)
	GrantRoleToStation(ctx context.Context, in *GrantRoleReq, opts ...grpc.CallOption) (*BaseResp, error)
	GrantStationToUser(ctx context.Context, in *StationUserReq, opts ...grpc.CallOption) (*BaseResp, error)
	ReplaceStationUser(ctx context.Context, in *ReplaceUserReq, opts ...grpc.CallOption) (*BaseResp, error)
	GetStationList(ctx context.Context, in *PageInfoReq, opts ...grpc.CallOption) (*GetStationListResp, error)
}

type stationClient struct {
	cc grpc.ClientConnInterface
}

func NewStationClient(cc grpc.ClientConnInterface) StationClient {
	return &stationClient{cc}
}

func (c *stationClient) CreateStation(ctx context.Context, in *CreateStationReq, opts ...grpc.CallOption) (*BaseResp, error) {
	out := new(BaseResp)
	err := c.cc.Invoke(ctx, "/pb.Station/CreateStation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stationClient) DeleteStation(ctx context.Context, in *IDResp, opts ...grpc.CallOption) (*BaseResp, error) {
	out := new(BaseResp)
	err := c.cc.Invoke(ctx, "/pb.Station/DeleteStation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stationClient) GetStation(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*GetStationResp, error) {
	out := new(GetStationResp)
	err := c.cc.Invoke(ctx, "/pb.Station/GetStation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stationClient) GetStationByUser(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*GetStationByUserResp, error) {
	out := new(GetStationByUserResp)
	err := c.cc.Invoke(ctx, "/pb.Station/GetStationByUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stationClient) UpdateStation(ctx context.Context, in *UpdateStationReq, opts ...grpc.CallOption) (*BaseResp, error) {
	out := new(BaseResp)
	err := c.cc.Invoke(ctx, "/pb.Station/UpdateStation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stationClient) UpdateStationSort(ctx context.Context, in *ChangePositionReq, opts ...grpc.CallOption) (*BaseResp, error) {
	out := new(BaseResp)
	err := c.cc.Invoke(ctx, "/pb.Station/UpdateStationSort", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stationClient) UpdateDep(ctx context.Context, in *ChangeDept, opts ...grpc.CallOption) (*BaseResp, error) {
	out := new(BaseResp)
	err := c.cc.Invoke(ctx, "/pb.Station/UpdateDep", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stationClient) GrantRoleToStation(ctx context.Context, in *GrantRoleReq, opts ...grpc.CallOption) (*BaseResp, error) {
	out := new(BaseResp)
	err := c.cc.Invoke(ctx, "/pb.Station/GrantRoleToStation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stationClient) GrantStationToUser(ctx context.Context, in *StationUserReq, opts ...grpc.CallOption) (*BaseResp, error) {
	out := new(BaseResp)
	err := c.cc.Invoke(ctx, "/pb.Station/GrantStationToUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stationClient) ReplaceStationUser(ctx context.Context, in *ReplaceUserReq, opts ...grpc.CallOption) (*BaseResp, error) {
	out := new(BaseResp)
	err := c.cc.Invoke(ctx, "/pb.Station/ReplaceStationUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stationClient) GetStationList(ctx context.Context, in *PageInfoReq, opts ...grpc.CallOption) (*GetStationListResp, error) {
	out := new(GetStationListResp)
	err := c.cc.Invoke(ctx, "/pb.Station/GetStationList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StationServer is the server API for Station service.
// All implementations must embed UnimplementedStationServer
// for forward compatibility
type StationServer interface {
	CreateStation(context.Context, *CreateStationReq) (*BaseResp, error)
	DeleteStation(context.Context, *IDResp) (*BaseResp, error)
	GetStation(context.Context, *IDReq) (*GetStationResp, error)
	GetStationByUser(context.Context, *IDReq) (*GetStationByUserResp, error)
	UpdateStation(context.Context, *UpdateStationReq) (*BaseResp, error)
	UpdateStationSort(context.Context, *ChangePositionReq) (*BaseResp, error)
	UpdateDep(context.Context, *ChangeDept) (*BaseResp, error)
	GrantRoleToStation(context.Context, *GrantRoleReq) (*BaseResp, error)
	GrantStationToUser(context.Context, *StationUserReq) (*BaseResp, error)
	ReplaceStationUser(context.Context, *ReplaceUserReq) (*BaseResp, error)
	GetStationList(context.Context, *PageInfoReq) (*GetStationListResp, error)
	mustEmbedUnimplementedStationServer()
}

// UnimplementedStationServer must be embedded to have forward compatible implementations.
type UnimplementedStationServer struct {
}

func (UnimplementedStationServer) CreateStation(context.Context, *CreateStationReq) (*BaseResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateStation not implemented")
}
func (UnimplementedStationServer) DeleteStation(context.Context, *IDResp) (*BaseResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteStation not implemented")
}
func (UnimplementedStationServer) GetStation(context.Context, *IDReq) (*GetStationResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStation not implemented")
}
func (UnimplementedStationServer) GetStationByUser(context.Context, *IDReq) (*GetStationByUserResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStationByUser not implemented")
}
func (UnimplementedStationServer) UpdateStation(context.Context, *UpdateStationReq) (*BaseResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateStation not implemented")
}
func (UnimplementedStationServer) UpdateStationSort(context.Context, *ChangePositionReq) (*BaseResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateStationSort not implemented")
}
func (UnimplementedStationServer) UpdateDep(context.Context, *ChangeDept) (*BaseResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDep not implemented")
}
func (UnimplementedStationServer) GrantRoleToStation(context.Context, *GrantRoleReq) (*BaseResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GrantRoleToStation not implemented")
}
func (UnimplementedStationServer) GrantStationToUser(context.Context, *StationUserReq) (*BaseResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GrantStationToUser not implemented")
}
func (UnimplementedStationServer) ReplaceStationUser(context.Context, *ReplaceUserReq) (*BaseResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReplaceStationUser not implemented")
}
func (UnimplementedStationServer) GetStationList(context.Context, *PageInfoReq) (*GetStationListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStationList not implemented")
}
func (UnimplementedStationServer) mustEmbedUnimplementedStationServer() {}

// UnsafeStationServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StationServer will
// result in compilation errors.
type UnsafeStationServer interface {
	mustEmbedUnimplementedStationServer()
}

func RegisterStationServer(s grpc.ServiceRegistrar, srv StationServer) {
	s.RegisterService(&Station_ServiceDesc, srv)
}

func _Station_CreateStation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateStationReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StationServer).CreateStation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Station/CreateStation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StationServer).CreateStation(ctx, req.(*CreateStationReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Station_DeleteStation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDResp)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StationServer).DeleteStation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Station/DeleteStation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StationServer).DeleteStation(ctx, req.(*IDResp))
	}
	return interceptor(ctx, in, info, handler)
}

func _Station_GetStation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StationServer).GetStation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Station/GetStation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StationServer).GetStation(ctx, req.(*IDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Station_GetStationByUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StationServer).GetStationByUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Station/GetStationByUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StationServer).GetStationByUser(ctx, req.(*IDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Station_UpdateStation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateStationReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StationServer).UpdateStation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Station/UpdateStation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StationServer).UpdateStation(ctx, req.(*UpdateStationReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Station_UpdateStationSort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangePositionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StationServer).UpdateStationSort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Station/UpdateStationSort",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StationServer).UpdateStationSort(ctx, req.(*ChangePositionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Station_UpdateDep_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangeDept)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StationServer).UpdateDep(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Station/UpdateDep",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StationServer).UpdateDep(ctx, req.(*ChangeDept))
	}
	return interceptor(ctx, in, info, handler)
}

func _Station_GrantRoleToStation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GrantRoleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StationServer).GrantRoleToStation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Station/GrantRoleToStation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StationServer).GrantRoleToStation(ctx, req.(*GrantRoleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Station_GrantStationToUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StationUserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StationServer).GrantStationToUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Station/GrantStationToUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StationServer).GrantStationToUser(ctx, req.(*StationUserReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Station_ReplaceStationUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReplaceUserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StationServer).ReplaceStationUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Station/ReplaceStationUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StationServer).ReplaceStationUser(ctx, req.(*ReplaceUserReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Station_GetStationList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PageInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StationServer).GetStationList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Station/GetStationList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StationServer).GetStationList(ctx, req.(*PageInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Station_ServiceDesc is the grpc.ServiceDesc for Station service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Station_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Station",
	HandlerType: (*StationServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateStation",
			Handler:    _Station_CreateStation_Handler,
		},
		{
			MethodName: "DeleteStation",
			Handler:    _Station_DeleteStation_Handler,
		},
		{
			MethodName: "GetStation",
			Handler:    _Station_GetStation_Handler,
		},
		{
			MethodName: "GetStationByUser",
			Handler:    _Station_GetStationByUser_Handler,
		},
		{
			MethodName: "UpdateStation",
			Handler:    _Station_UpdateStation_Handler,
		},
		{
			MethodName: "UpdateStationSort",
			Handler:    _Station_UpdateStationSort_Handler,
		},
		{
			MethodName: "UpdateDep",
			Handler:    _Station_UpdateDep_Handler,
		},
		{
			MethodName: "GrantRoleToStation",
			Handler:    _Station_GrantRoleToStation_Handler,
		},
		{
			MethodName: "GrantStationToUser",
			Handler:    _Station_GrantStationToUser_Handler,
		},
		{
			MethodName: "ReplaceStationUser",
			Handler:    _Station_ReplaceStationUser_Handler,
		},
		{
			MethodName: "GetStationList",
			Handler:    _Station_GetStationList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "usercenter.proto",
}

// RoleClient is the client API for Role service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RoleClient interface {
	CreateRole(ctx context.Context, in *CreateRoleReq, opts ...grpc.CallOption) (*BaseResp, error)
	DeleteRole(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*BaseResp, error)
	UpdateRole(ctx context.Context, in *UpdateRoleReq, opts ...grpc.CallOption) (*BaseResp, error)
	GetRole(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*GetRoleResp, error)
	GrantMenuToRole(ctx context.Context, in *GrantMenuToRoleReq, opts ...grpc.CallOption) (*BaseResp, error)
	GrantApiToRole(ctx context.Context, in *GrantApiToRoleReq, opts ...grpc.CallOption) (*BaseResp, error)
	GrantRoleToStation(ctx context.Context, in *GrantRoleToStationReq, opts ...grpc.CallOption) (*BaseResp, error)
	GetRoleList(ctx context.Context, in *PageInfoReq, opts ...grpc.CallOption) (*RoleListResp, error)
}

type roleClient struct {
	cc grpc.ClientConnInterface
}

func NewRoleClient(cc grpc.ClientConnInterface) RoleClient {
	return &roleClient{cc}
}

func (c *roleClient) CreateRole(ctx context.Context, in *CreateRoleReq, opts ...grpc.CallOption) (*BaseResp, error) {
	out := new(BaseResp)
	err := c.cc.Invoke(ctx, "/pb.Role/CreateRole", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleClient) DeleteRole(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*BaseResp, error) {
	out := new(BaseResp)
	err := c.cc.Invoke(ctx, "/pb.Role/DeleteRole", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleClient) UpdateRole(ctx context.Context, in *UpdateRoleReq, opts ...grpc.CallOption) (*BaseResp, error) {
	out := new(BaseResp)
	err := c.cc.Invoke(ctx, "/pb.Role/UpdateRole", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleClient) GetRole(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*GetRoleResp, error) {
	out := new(GetRoleResp)
	err := c.cc.Invoke(ctx, "/pb.Role/GetRole", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleClient) GrantMenuToRole(ctx context.Context, in *GrantMenuToRoleReq, opts ...grpc.CallOption) (*BaseResp, error) {
	out := new(BaseResp)
	err := c.cc.Invoke(ctx, "/pb.Role/GrantMenuToRole", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleClient) GrantApiToRole(ctx context.Context, in *GrantApiToRoleReq, opts ...grpc.CallOption) (*BaseResp, error) {
	out := new(BaseResp)
	err := c.cc.Invoke(ctx, "/pb.Role/GrantApiToRole", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleClient) GrantRoleToStation(ctx context.Context, in *GrantRoleToStationReq, opts ...grpc.CallOption) (*BaseResp, error) {
	out := new(BaseResp)
	err := c.cc.Invoke(ctx, "/pb.Role/GrantRoleToStation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleClient) GetRoleList(ctx context.Context, in *PageInfoReq, opts ...grpc.CallOption) (*RoleListResp, error) {
	out := new(RoleListResp)
	err := c.cc.Invoke(ctx, "/pb.Role/GetRoleList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RoleServer is the server API for Role service.
// All implementations must embed UnimplementedRoleServer
// for forward compatibility
type RoleServer interface {
	CreateRole(context.Context, *CreateRoleReq) (*BaseResp, error)
	DeleteRole(context.Context, *IDReq) (*BaseResp, error)
	UpdateRole(context.Context, *UpdateRoleReq) (*BaseResp, error)
	GetRole(context.Context, *IDReq) (*GetRoleResp, error)
	GrantMenuToRole(context.Context, *GrantMenuToRoleReq) (*BaseResp, error)
	GrantApiToRole(context.Context, *GrantApiToRoleReq) (*BaseResp, error)
	GrantRoleToStation(context.Context, *GrantRoleToStationReq) (*BaseResp, error)
	GetRoleList(context.Context, *PageInfoReq) (*RoleListResp, error)
	mustEmbedUnimplementedRoleServer()
}

// UnimplementedRoleServer must be embedded to have forward compatible implementations.
type UnimplementedRoleServer struct {
}

func (UnimplementedRoleServer) CreateRole(context.Context, *CreateRoleReq) (*BaseResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateRole not implemented")
}
func (UnimplementedRoleServer) DeleteRole(context.Context, *IDReq) (*BaseResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRole not implemented")
}
func (UnimplementedRoleServer) UpdateRole(context.Context, *UpdateRoleReq) (*BaseResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateRole not implemented")
}
func (UnimplementedRoleServer) GetRole(context.Context, *IDReq) (*GetRoleResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRole not implemented")
}
func (UnimplementedRoleServer) GrantMenuToRole(context.Context, *GrantMenuToRoleReq) (*BaseResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GrantMenuToRole not implemented")
}
func (UnimplementedRoleServer) GrantApiToRole(context.Context, *GrantApiToRoleReq) (*BaseResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GrantApiToRole not implemented")
}
func (UnimplementedRoleServer) GrantRoleToStation(context.Context, *GrantRoleToStationReq) (*BaseResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GrantRoleToStation not implemented")
}
func (UnimplementedRoleServer) GetRoleList(context.Context, *PageInfoReq) (*RoleListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRoleList not implemented")
}
func (UnimplementedRoleServer) mustEmbedUnimplementedRoleServer() {}

// UnsafeRoleServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RoleServer will
// result in compilation errors.
type UnsafeRoleServer interface {
	mustEmbedUnimplementedRoleServer()
}

func RegisterRoleServer(s grpc.ServiceRegistrar, srv RoleServer) {
	s.RegisterService(&Role_ServiceDesc, srv)
}

func _Role_CreateRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRoleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServer).CreateRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Role/CreateRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServer).CreateRole(ctx, req.(*CreateRoleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Role_DeleteRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServer).DeleteRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Role/DeleteRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServer).DeleteRole(ctx, req.(*IDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Role_UpdateRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRoleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServer).UpdateRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Role/UpdateRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServer).UpdateRole(ctx, req.(*UpdateRoleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Role_GetRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServer).GetRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Role/GetRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServer).GetRole(ctx, req.(*IDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Role_GrantMenuToRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GrantMenuToRoleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServer).GrantMenuToRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Role/GrantMenuToRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServer).GrantMenuToRole(ctx, req.(*GrantMenuToRoleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Role_GrantApiToRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GrantApiToRoleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServer).GrantApiToRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Role/GrantApiToRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServer).GrantApiToRole(ctx, req.(*GrantApiToRoleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Role_GrantRoleToStation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GrantRoleToStationReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServer).GrantRoleToStation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Role/GrantRoleToStation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServer).GrantRoleToStation(ctx, req.(*GrantRoleToStationReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Role_GetRoleList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PageInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServer).GetRoleList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Role/GetRoleList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServer).GetRoleList(ctx, req.(*PageInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Role_ServiceDesc is the grpc.ServiceDesc for Role service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Role_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Role",
	HandlerType: (*RoleServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateRole",
			Handler:    _Role_CreateRole_Handler,
		},
		{
			MethodName: "DeleteRole",
			Handler:    _Role_DeleteRole_Handler,
		},
		{
			MethodName: "UpdateRole",
			Handler:    _Role_UpdateRole_Handler,
		},
		{
			MethodName: "GetRole",
			Handler:    _Role_GetRole_Handler,
		},
		{
			MethodName: "GrantMenuToRole",
			Handler:    _Role_GrantMenuToRole_Handler,
		},
		{
			MethodName: "GrantApiToRole",
			Handler:    _Role_GrantApiToRole_Handler,
		},
		{
			MethodName: "GrantRoleToStation",
			Handler:    _Role_GrantRoleToStation_Handler,
		},
		{
			MethodName: "GetRoleList",
			Handler:    _Role_GetRoleList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "usercenter.proto",
}

// MenuClient is the client API for Menu service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MenuClient interface {
	CreateMenu(ctx context.Context, in *CreateMenuReq, opts ...grpc.CallOption) (*BaseResp, error)
	UpdateMenu(ctx context.Context, in *UpdateMenuReq, opts ...grpc.CallOption) (*BaseResp, error)
	DeleteMenu(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*BaseResp, error)
	CreateMenuParam(ctx context.Context, in *CreateMenuParamReq, opts ...grpc.CallOption) (*BaseResp, error)
	DeleteParams(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*BaseResp, error)
	GetMenuList(ctx context.Context, in *GetMenuListReq, opts ...grpc.CallOption) (*GetMenuListResp, error)
	GetParamsByMenu(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*GetParamsByMenuResp, error)
	UpdateMenuParams(ctx context.Context, in *UpdateMenuParamsReq, opts ...grpc.CallOption) (*BaseResp, error)
}

type menuClient struct {
	cc grpc.ClientConnInterface
}

func NewMenuClient(cc grpc.ClientConnInterface) MenuClient {
	return &menuClient{cc}
}

func (c *menuClient) CreateMenu(ctx context.Context, in *CreateMenuReq, opts ...grpc.CallOption) (*BaseResp, error) {
	out := new(BaseResp)
	err := c.cc.Invoke(ctx, "/pb.Menu/CreateMenu", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuClient) UpdateMenu(ctx context.Context, in *UpdateMenuReq, opts ...grpc.CallOption) (*BaseResp, error) {
	out := new(BaseResp)
	err := c.cc.Invoke(ctx, "/pb.Menu/UpdateMenu", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuClient) DeleteMenu(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*BaseResp, error) {
	out := new(BaseResp)
	err := c.cc.Invoke(ctx, "/pb.Menu/DeleteMenu", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuClient) CreateMenuParam(ctx context.Context, in *CreateMenuParamReq, opts ...grpc.CallOption) (*BaseResp, error) {
	out := new(BaseResp)
	err := c.cc.Invoke(ctx, "/pb.Menu/CreateMenuParam", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuClient) DeleteParams(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*BaseResp, error) {
	out := new(BaseResp)
	err := c.cc.Invoke(ctx, "/pb.Menu/DeleteParams", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuClient) GetMenuList(ctx context.Context, in *GetMenuListReq, opts ...grpc.CallOption) (*GetMenuListResp, error) {
	out := new(GetMenuListResp)
	err := c.cc.Invoke(ctx, "/pb.Menu/GetMenuList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuClient) GetParamsByMenu(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*GetParamsByMenuResp, error) {
	out := new(GetParamsByMenuResp)
	err := c.cc.Invoke(ctx, "/pb.Menu/GetParamsByMenu", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuClient) UpdateMenuParams(ctx context.Context, in *UpdateMenuParamsReq, opts ...grpc.CallOption) (*BaseResp, error) {
	out := new(BaseResp)
	err := c.cc.Invoke(ctx, "/pb.Menu/UpdateMenuParams", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MenuServer is the server API for Menu service.
// All implementations must embed UnimplementedMenuServer
// for forward compatibility
type MenuServer interface {
	CreateMenu(context.Context, *CreateMenuReq) (*BaseResp, error)
	UpdateMenu(context.Context, *UpdateMenuReq) (*BaseResp, error)
	DeleteMenu(context.Context, *IDReq) (*BaseResp, error)
	CreateMenuParam(context.Context, *CreateMenuParamReq) (*BaseResp, error)
	DeleteParams(context.Context, *IDReq) (*BaseResp, error)
	GetMenuList(context.Context, *GetMenuListReq) (*GetMenuListResp, error)
	GetParamsByMenu(context.Context, *IDReq) (*GetParamsByMenuResp, error)
	UpdateMenuParams(context.Context, *UpdateMenuParamsReq) (*BaseResp, error)
	mustEmbedUnimplementedMenuServer()
}

// UnimplementedMenuServer must be embedded to have forward compatible implementations.
type UnimplementedMenuServer struct {
}

func (UnimplementedMenuServer) CreateMenu(context.Context, *CreateMenuReq) (*BaseResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateMenu not implemented")
}
func (UnimplementedMenuServer) UpdateMenu(context.Context, *UpdateMenuReq) (*BaseResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMenu not implemented")
}
func (UnimplementedMenuServer) DeleteMenu(context.Context, *IDReq) (*BaseResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteMenu not implemented")
}
func (UnimplementedMenuServer) CreateMenuParam(context.Context, *CreateMenuParamReq) (*BaseResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateMenuParam not implemented")
}
func (UnimplementedMenuServer) DeleteParams(context.Context, *IDReq) (*BaseResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteParams not implemented")
}
func (UnimplementedMenuServer) GetMenuList(context.Context, *GetMenuListReq) (*GetMenuListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMenuList not implemented")
}
func (UnimplementedMenuServer) GetParamsByMenu(context.Context, *IDReq) (*GetParamsByMenuResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetParamsByMenu not implemented")
}
func (UnimplementedMenuServer) UpdateMenuParams(context.Context, *UpdateMenuParamsReq) (*BaseResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMenuParams not implemented")
}
func (UnimplementedMenuServer) mustEmbedUnimplementedMenuServer() {}

// UnsafeMenuServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MenuServer will
// result in compilation errors.
type UnsafeMenuServer interface {
	mustEmbedUnimplementedMenuServer()
}

func RegisterMenuServer(s grpc.ServiceRegistrar, srv MenuServer) {
	s.RegisterService(&Menu_ServiceDesc, srv)
}

func _Menu_CreateMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateMenuReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServer).CreateMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Menu/CreateMenu",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServer).CreateMenu(ctx, req.(*CreateMenuReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Menu_UpdateMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMenuReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServer).UpdateMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Menu/UpdateMenu",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServer).UpdateMenu(ctx, req.(*UpdateMenuReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Menu_DeleteMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServer).DeleteMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Menu/DeleteMenu",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServer).DeleteMenu(ctx, req.(*IDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Menu_CreateMenuParam_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateMenuParamReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServer).CreateMenuParam(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Menu/CreateMenuParam",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServer).CreateMenuParam(ctx, req.(*CreateMenuParamReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Menu_DeleteParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServer).DeleteParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Menu/DeleteParams",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServer).DeleteParams(ctx, req.(*IDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Menu_GetMenuList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMenuListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServer).GetMenuList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Menu/GetMenuList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServer).GetMenuList(ctx, req.(*GetMenuListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Menu_GetParamsByMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServer).GetParamsByMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Menu/GetParamsByMenu",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServer).GetParamsByMenu(ctx, req.(*IDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Menu_UpdateMenuParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMenuParamsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServer).UpdateMenuParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Menu/UpdateMenuParams",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServer).UpdateMenuParams(ctx, req.(*UpdateMenuParamsReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Menu_ServiceDesc is the grpc.ServiceDesc for Menu service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Menu_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Menu",
	HandlerType: (*MenuServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateMenu",
			Handler:    _Menu_CreateMenu_Handler,
		},
		{
			MethodName: "UpdateMenu",
			Handler:    _Menu_UpdateMenu_Handler,
		},
		{
			MethodName: "DeleteMenu",
			Handler:    _Menu_DeleteMenu_Handler,
		},
		{
			MethodName: "CreateMenuParam",
			Handler:    _Menu_CreateMenuParam_Handler,
		},
		{
			MethodName: "DeleteParams",
			Handler:    _Menu_DeleteParams_Handler,
		},
		{
			MethodName: "GetMenuList",
			Handler:    _Menu_GetMenuList_Handler,
		},
		{
			MethodName: "GetParamsByMenu",
			Handler:    _Menu_GetParamsByMenu_Handler,
		},
		{
			MethodName: "UpdateMenuParams",
			Handler:    _Menu_UpdateMenuParams_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "usercenter.proto",
}

// TenantClient is the client API for Tenant service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TenantClient interface {
	CreateTenant(ctx context.Context, in *CreateTenantReq, opts ...grpc.CallOption) (*BaseResp, error)
	DeleteTenant(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*BaseResp, error)
	UpdateTenant(ctx context.Context, in *UpdateTenantReq, opts ...grpc.CallOption) (*BaseResp, error)
	GetTenant(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*GetTenantResp, error)
	GrantMenuToRole(ctx context.Context, in *GrantMenusToRoleReq, opts ...grpc.CallOption) (*BaseResp, error)
	UpdateTenantPeriod(ctx context.Context, in *UpdatePeriodReq, opts ...grpc.CallOption) (*BaseResp, error)
	UpdateTenantStatus(ctx context.Context, in *UpdateStatusReq, opts ...grpc.CallOption) (*BaseResp, error)
	GetTenantList(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*GetTeantListResp, error)
}

type tenantClient struct {
	cc grpc.ClientConnInterface
}

func NewTenantClient(cc grpc.ClientConnInterface) TenantClient {
	return &tenantClient{cc}
}

func (c *tenantClient) CreateTenant(ctx context.Context, in *CreateTenantReq, opts ...grpc.CallOption) (*BaseResp, error) {
	out := new(BaseResp)
	err := c.cc.Invoke(ctx, "/pb.Tenant/CreateTenant", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantClient) DeleteTenant(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*BaseResp, error) {
	out := new(BaseResp)
	err := c.cc.Invoke(ctx, "/pb.Tenant/DeleteTenant", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantClient) UpdateTenant(ctx context.Context, in *UpdateTenantReq, opts ...grpc.CallOption) (*BaseResp, error) {
	out := new(BaseResp)
	err := c.cc.Invoke(ctx, "/pb.Tenant/UpdateTenant", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantClient) GetTenant(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*GetTenantResp, error) {
	out := new(GetTenantResp)
	err := c.cc.Invoke(ctx, "/pb.Tenant/GetTenant", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantClient) GrantMenuToRole(ctx context.Context, in *GrantMenusToRoleReq, opts ...grpc.CallOption) (*BaseResp, error) {
	out := new(BaseResp)
	err := c.cc.Invoke(ctx, "/pb.Tenant/GrantMenuToRole", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantClient) UpdateTenantPeriod(ctx context.Context, in *UpdatePeriodReq, opts ...grpc.CallOption) (*BaseResp, error) {
	out := new(BaseResp)
	err := c.cc.Invoke(ctx, "/pb.Tenant/UpdateTenantPeriod", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantClient) UpdateTenantStatus(ctx context.Context, in *UpdateStatusReq, opts ...grpc.CallOption) (*BaseResp, error) {
	out := new(BaseResp)
	err := c.cc.Invoke(ctx, "/pb.Tenant/UpdateTenantStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantClient) GetTenantList(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*GetTeantListResp, error) {
	out := new(GetTeantListResp)
	err := c.cc.Invoke(ctx, "/pb.Tenant/GetTenantList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TenantServer is the server API for Tenant service.
// All implementations must embed UnimplementedTenantServer
// for forward compatibility
type TenantServer interface {
	CreateTenant(context.Context, *CreateTenantReq) (*BaseResp, error)
	DeleteTenant(context.Context, *IDReq) (*BaseResp, error)
	UpdateTenant(context.Context, *UpdateTenantReq) (*BaseResp, error)
	GetTenant(context.Context, *IDReq) (*GetTenantResp, error)
	GrantMenuToRole(context.Context, *GrantMenusToRoleReq) (*BaseResp, error)
	UpdateTenantPeriod(context.Context, *UpdatePeriodReq) (*BaseResp, error)
	UpdateTenantStatus(context.Context, *UpdateStatusReq) (*BaseResp, error)
	GetTenantList(context.Context, *IDReq) (*GetTeantListResp, error)
	mustEmbedUnimplementedTenantServer()
}

// UnimplementedTenantServer must be embedded to have forward compatible implementations.
type UnimplementedTenantServer struct {
}

func (UnimplementedTenantServer) CreateTenant(context.Context, *CreateTenantReq) (*BaseResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTenant not implemented")
}
func (UnimplementedTenantServer) DeleteTenant(context.Context, *IDReq) (*BaseResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTenant not implemented")
}
func (UnimplementedTenantServer) UpdateTenant(context.Context, *UpdateTenantReq) (*BaseResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTenant not implemented")
}
func (UnimplementedTenantServer) GetTenant(context.Context, *IDReq) (*GetTenantResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTenant not implemented")
}
func (UnimplementedTenantServer) GrantMenuToRole(context.Context, *GrantMenusToRoleReq) (*BaseResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GrantMenuToRole not implemented")
}
func (UnimplementedTenantServer) UpdateTenantPeriod(context.Context, *UpdatePeriodReq) (*BaseResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTenantPeriod not implemented")
}
func (UnimplementedTenantServer) UpdateTenantStatus(context.Context, *UpdateStatusReq) (*BaseResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTenantStatus not implemented")
}
func (UnimplementedTenantServer) GetTenantList(context.Context, *IDReq) (*GetTeantListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTenantList not implemented")
}
func (UnimplementedTenantServer) mustEmbedUnimplementedTenantServer() {}

// UnsafeTenantServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TenantServer will
// result in compilation errors.
type UnsafeTenantServer interface {
	mustEmbedUnimplementedTenantServer()
}

func RegisterTenantServer(s grpc.ServiceRegistrar, srv TenantServer) {
	s.RegisterService(&Tenant_ServiceDesc, srv)
}

func _Tenant_CreateTenant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTenantReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantServer).CreateTenant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Tenant/CreateTenant",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantServer).CreateTenant(ctx, req.(*CreateTenantReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tenant_DeleteTenant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantServer).DeleteTenant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Tenant/DeleteTenant",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantServer).DeleteTenant(ctx, req.(*IDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tenant_UpdateTenant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTenantReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantServer).UpdateTenant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Tenant/UpdateTenant",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantServer).UpdateTenant(ctx, req.(*UpdateTenantReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tenant_GetTenant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantServer).GetTenant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Tenant/GetTenant",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantServer).GetTenant(ctx, req.(*IDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tenant_GrantMenuToRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GrantMenusToRoleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantServer).GrantMenuToRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Tenant/GrantMenuToRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantServer).GrantMenuToRole(ctx, req.(*GrantMenusToRoleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tenant_UpdateTenantPeriod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePeriodReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantServer).UpdateTenantPeriod(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Tenant/UpdateTenantPeriod",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantServer).UpdateTenantPeriod(ctx, req.(*UpdatePeriodReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tenant_UpdateTenantStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateStatusReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantServer).UpdateTenantStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Tenant/UpdateTenantStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantServer).UpdateTenantStatus(ctx, req.(*UpdateStatusReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tenant_GetTenantList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantServer).GetTenantList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Tenant/GetTenantList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantServer).GetTenantList(ctx, req.(*IDReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Tenant_ServiceDesc is the grpc.ServiceDesc for Tenant service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Tenant_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Tenant",
	HandlerType: (*TenantServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateTenant",
			Handler:    _Tenant_CreateTenant_Handler,
		},
		{
			MethodName: "DeleteTenant",
			Handler:    _Tenant_DeleteTenant_Handler,
		},
		{
			MethodName: "UpdateTenant",
			Handler:    _Tenant_UpdateTenant_Handler,
		},
		{
			MethodName: "GetTenant",
			Handler:    _Tenant_GetTenant_Handler,
		},
		{
			MethodName: "GrantMenuToRole",
			Handler:    _Tenant_GrantMenuToRole_Handler,
		},
		{
			MethodName: "UpdateTenantPeriod",
			Handler:    _Tenant_UpdateTenantPeriod_Handler,
		},
		{
			MethodName: "UpdateTenantStatus",
			Handler:    _Tenant_UpdateTenantStatus_Handler,
		},
		{
			MethodName: "GetTenantList",
			Handler:    _Tenant_GetTenantList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "usercenter.proto",
}

// ApiClient is the client API for Api service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ApiClient interface {
	CreateApi(ctx context.Context, in *CreateApiReq, opts ...grpc.CallOption) (*BaseResp, error)
	DeleteApi(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*BaseResp, error)
	UpdateApi(ctx context.Context, in *UpdateApiReq, opts ...grpc.CallOption) (*BaseResp, error)
	GetApi(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*GetApiResp, error)
	GetApiListByMenu(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*GetApiListResp, error)
}

type apiClient struct {
	cc grpc.ClientConnInterface
}

func NewApiClient(cc grpc.ClientConnInterface) ApiClient {
	return &apiClient{cc}
}

func (c *apiClient) CreateApi(ctx context.Context, in *CreateApiReq, opts ...grpc.CallOption) (*BaseResp, error) {
	out := new(BaseResp)
	err := c.cc.Invoke(ctx, "/pb.Api/CreateApi", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiClient) DeleteApi(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*BaseResp, error) {
	out := new(BaseResp)
	err := c.cc.Invoke(ctx, "/pb.Api/DeleteApi", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiClient) UpdateApi(ctx context.Context, in *UpdateApiReq, opts ...grpc.CallOption) (*BaseResp, error) {
	out := new(BaseResp)
	err := c.cc.Invoke(ctx, "/pb.Api/UpdateApi", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiClient) GetApi(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*GetApiResp, error) {
	out := new(GetApiResp)
	err := c.cc.Invoke(ctx, "/pb.Api/GetApi", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiClient) GetApiListByMenu(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*GetApiListResp, error) {
	out := new(GetApiListResp)
	err := c.cc.Invoke(ctx, "/pb.Api/GetApiListByMenu", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ApiServer is the server API for Api service.
// All implementations must embed UnimplementedApiServer
// for forward compatibility
type ApiServer interface {
	CreateApi(context.Context, *CreateApiReq) (*BaseResp, error)
	DeleteApi(context.Context, *IDReq) (*BaseResp, error)
	UpdateApi(context.Context, *UpdateApiReq) (*BaseResp, error)
	GetApi(context.Context, *IDReq) (*GetApiResp, error)
	GetApiListByMenu(context.Context, *IDReq) (*GetApiListResp, error)
	mustEmbedUnimplementedApiServer()
}

// UnimplementedApiServer must be embedded to have forward compatible implementations.
type UnimplementedApiServer struct {
}

func (UnimplementedApiServer) CreateApi(context.Context, *CreateApiReq) (*BaseResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateApi not implemented")
}
func (UnimplementedApiServer) DeleteApi(context.Context, *IDReq) (*BaseResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteApi not implemented")
}
func (UnimplementedApiServer) UpdateApi(context.Context, *UpdateApiReq) (*BaseResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateApi not implemented")
}
func (UnimplementedApiServer) GetApi(context.Context, *IDReq) (*GetApiResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetApi not implemented")
}
func (UnimplementedApiServer) GetApiListByMenu(context.Context, *IDReq) (*GetApiListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetApiListByMenu not implemented")
}
func (UnimplementedApiServer) mustEmbedUnimplementedApiServer() {}

// UnsafeApiServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ApiServer will
// result in compilation errors.
type UnsafeApiServer interface {
	mustEmbedUnimplementedApiServer()
}

func RegisterApiServer(s grpc.ServiceRegistrar, srv ApiServer) {
	s.RegisterService(&Api_ServiceDesc, srv)
}

func _Api_CreateApi_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateApiReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServer).CreateApi(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Api/CreateApi",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServer).CreateApi(ctx, req.(*CreateApiReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Api_DeleteApi_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServer).DeleteApi(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Api/DeleteApi",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServer).DeleteApi(ctx, req.(*IDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Api_UpdateApi_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateApiReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServer).UpdateApi(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Api/UpdateApi",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServer).UpdateApi(ctx, req.(*UpdateApiReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Api_GetApi_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServer).GetApi(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Api/GetApi",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServer).GetApi(ctx, req.(*IDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Api_GetApiListByMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServer).GetApiListByMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Api/GetApiListByMenu",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServer).GetApiListByMenu(ctx, req.(*IDReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Api_ServiceDesc is the grpc.ServiceDesc for Api service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Api_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Api",
	HandlerType: (*ApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateApi",
			Handler:    _Api_CreateApi_Handler,
		},
		{
			MethodName: "DeleteApi",
			Handler:    _Api_DeleteApi_Handler,
		},
		{
			MethodName: "UpdateApi",
			Handler:    _Api_UpdateApi_Handler,
		},
		{
			MethodName: "GetApi",
			Handler:    _Api_GetApi_Handler,
		},
		{
			MethodName: "GetApiListByMenu",
			Handler:    _Api_GetApiListByMenu_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "usercenter.proto",
}

// TokenClient is the client API for Token service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TokenClient interface {
	CreateToken(ctx context.Context, in *CreateTokenReq, opts ...grpc.CallOption) (*BaseResp, error)
	DeleteToken(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*BaseResp, error)
	GetToken(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*GetTokenResp, error)
	GetTokenList(ctx context.Context, in *GetTokenListReq, opts ...grpc.CallOption) (*GetTokenListResp, error)
	BlockAllTokenByUser(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*BaseResp, error)
}

type tokenClient struct {
	cc grpc.ClientConnInterface
}

func NewTokenClient(cc grpc.ClientConnInterface) TokenClient {
	return &tokenClient{cc}
}

func (c *tokenClient) CreateToken(ctx context.Context, in *CreateTokenReq, opts ...grpc.CallOption) (*BaseResp, error) {
	out := new(BaseResp)
	err := c.cc.Invoke(ctx, "/pb.Token/CreateToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tokenClient) DeleteToken(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*BaseResp, error) {
	out := new(BaseResp)
	err := c.cc.Invoke(ctx, "/pb.Token/DeleteToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tokenClient) GetToken(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*GetTokenResp, error) {
	out := new(GetTokenResp)
	err := c.cc.Invoke(ctx, "/pb.Token/GetToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tokenClient) GetTokenList(ctx context.Context, in *GetTokenListReq, opts ...grpc.CallOption) (*GetTokenListResp, error) {
	out := new(GetTokenListResp)
	err := c.cc.Invoke(ctx, "/pb.Token/GetTokenList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tokenClient) BlockAllTokenByUser(ctx context.Context, in *IDReq, opts ...grpc.CallOption) (*BaseResp, error) {
	out := new(BaseResp)
	err := c.cc.Invoke(ctx, "/pb.Token/BlockAllTokenByUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TokenServer is the server API for Token service.
// All implementations must embed UnimplementedTokenServer
// for forward compatibility
type TokenServer interface {
	CreateToken(context.Context, *CreateTokenReq) (*BaseResp, error)
	DeleteToken(context.Context, *IDReq) (*BaseResp, error)
	GetToken(context.Context, *IDReq) (*GetTokenResp, error)
	GetTokenList(context.Context, *GetTokenListReq) (*GetTokenListResp, error)
	BlockAllTokenByUser(context.Context, *IDReq) (*BaseResp, error)
	mustEmbedUnimplementedTokenServer()
}

// UnimplementedTokenServer must be embedded to have forward compatible implementations.
type UnimplementedTokenServer struct {
}

func (UnimplementedTokenServer) CreateToken(context.Context, *CreateTokenReq) (*BaseResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateToken not implemented")
}
func (UnimplementedTokenServer) DeleteToken(context.Context, *IDReq) (*BaseResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteToken not implemented")
}
func (UnimplementedTokenServer) GetToken(context.Context, *IDReq) (*GetTokenResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetToken not implemented")
}
func (UnimplementedTokenServer) GetTokenList(context.Context, *GetTokenListReq) (*GetTokenListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTokenList not implemented")
}
func (UnimplementedTokenServer) BlockAllTokenByUser(context.Context, *IDReq) (*BaseResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BlockAllTokenByUser not implemented")
}
func (UnimplementedTokenServer) mustEmbedUnimplementedTokenServer() {}

// UnsafeTokenServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TokenServer will
// result in compilation errors.
type UnsafeTokenServer interface {
	mustEmbedUnimplementedTokenServer()
}

func RegisterTokenServer(s grpc.ServiceRegistrar, srv TokenServer) {
	s.RegisterService(&Token_ServiceDesc, srv)
}

func _Token_CreateToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTokenReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokenServer).CreateToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Token/CreateToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokenServer).CreateToken(ctx, req.(*CreateTokenReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Token_DeleteToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokenServer).DeleteToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Token/DeleteToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokenServer).DeleteToken(ctx, req.(*IDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Token_GetToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokenServer).GetToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Token/GetToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokenServer).GetToken(ctx, req.(*IDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Token_GetTokenList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTokenListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokenServer).GetTokenList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Token/GetTokenList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokenServer).GetTokenList(ctx, req.(*GetTokenListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Token_BlockAllTokenByUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokenServer).BlockAllTokenByUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Token/BlockAllTokenByUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokenServer).BlockAllTokenByUser(ctx, req.(*IDReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Token_ServiceDesc is the grpc.ServiceDesc for Token service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Token_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Token",
	HandlerType: (*TokenServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateToken",
			Handler:    _Token_CreateToken_Handler,
		},
		{
			MethodName: "DeleteToken",
			Handler:    _Token_DeleteToken_Handler,
		},
		{
			MethodName: "GetToken",
			Handler:    _Token_GetToken_Handler,
		},
		{
			MethodName: "GetTokenList",
			Handler:    _Token_GetTokenList_Handler,
		},
		{
			MethodName: "BlockAllTokenByUser",
			Handler:    _Token_BlockAllTokenByUser_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "usercenter.proto",
}
